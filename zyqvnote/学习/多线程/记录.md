#### 线程方法
```
1. sleep:线程休眠，不放弃锁。
2. wait:在线程持有锁的情况下，放弃锁，线程变为等待获取锁的状态。在notify后， synchronized里面的语句会被执行完，同时值将会被刷新
3. yield:线程让步。假设线程a执行了a.yield,a还是有机会再次执行的
4. join:等待线程执行。假设在线程b中执行了a.join,那得等线程a执行完，b才能执行
```

#### 线程挂起和线程阻塞
```
线程挂起是底层的操作，线程阻塞在java中其实是通过线程挂起实现的。
另外一种是持续不断的try，lock。不能获取则放弃，然后一直执行。
```

maxIdle 最大空闲连接,maxActive包括maxIdle

1. 线程的interrupt，如果线程是运行状态，在调用这个方法后，标志位设为true,在线程进行了  
   wait，join，或者sleep，会抛出中断异常。如果线程先阻塞了，然后调用这个方法，同样会抛出异常。
2. lock在中断后依然会阻塞运行，而Interruptibly会在中断后结束

#### 偏向锁
```
Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。

偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。
(偏向锁只能在单线程下起作用)
因此 流程是这样的 偏向锁->轻量级锁->重量级锁
```